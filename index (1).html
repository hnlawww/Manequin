<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>3D Mannequin with Measurements</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Outfit:wght@200;300;400;500&display=swap');
  *{margin:0;padding:0;box-sizing:border-box}
  body,html{width:100%;height:100%;overflow:hidden;background:transparent;font-family:'Outfit',sans-serif}
  #scene-container{width:100%;height:100%;position:relative;cursor:grab;background:transparent}
  #scene-container:active{cursor:grabbing}
  canvas{display:block;width:100%;height:100%}
  .measurement-label{position:absolute;pointer-events:none;z-index:5;display:flex;align-items:center;gap:6px;opacity:0;transition:opacity 0.3s ease;font-family:'Outfit',sans-serif}
  .measurement-label.visible{opacity:1}
  .measurement-value{background:rgba(255,255,255,0.12);backdrop-filter:blur(12px);-webkit-backdrop-filter:blur(12px);border:1px solid rgba(255,255,255,0.25);border-radius:20px;padding:6px 14px;font-size:13px;font-weight:300;letter-spacing:0.8px;color:#1a1a2e;white-space:nowrap;box-shadow:0 4px 20px rgba(0,0,0,0.06)}
  .measurement-name{font-size:10px;font-weight:500;text-transform:uppercase;letter-spacing:2px;color:rgba(26,26,46,0.5);white-space:nowrap}
  .dot-indicator{width:6px;height:6px;border-radius:50%;background:rgba(26,26,46,0.3);border:1.5px solid rgba(26,26,46,0.15);flex-shrink:0}
</style>
</head>
<body>
<div id="scene-container">
  <canvas id="canvas3d"></canvas>
  <div class="measurement-label visible" id="label-arm"><div class="dot-indicator"></div><div><div class="measurement-value">32.5"</div><div class="measurement-name">Right Arm</div></div></div>
  <div class="measurement-label visible" id="label-chest"><div class="dot-indicator"></div><div><div class="measurement-value">40"</div><div class="measurement-name">Chest</div></div></div>
  <div class="measurement-label visible" id="label-waist"><div class="dot-indicator"></div><div><div class="measurement-value">34"</div><div class="measurement-name">Waist</div></div></div>
</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128/examples/js/loaders/GLTFLoader.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128/examples/js/loaders/DRACOLoader.js"></script>
<script>
(function() {
  var container = document.getElementById('scene-container');
  var canvas = document.getElementById('canvas3d');

  var scene = new THREE.Scene();
  var camera = new THREE.PerspectiveCamera(40, container.clientWidth / container.clientHeight, 0.1, 100);
  camera.position.set(0, 0.3, 4.5);

  var renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true, alpha: true });
  renderer.setClearColor(0x000000, 0);
  renderer.setSize(container.clientWidth, container.clientHeight);
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;
  renderer.toneMapping = THREE.ACESFilmicToneMapping;
  renderer.toneMappingExposure = 1.1;

  scene.add(new THREE.AmbientLight(0xdde1e8, 0.6));
  var kl = new THREE.DirectionalLight(0xffffff, 0.9);
  kl.position.set(3, 5, 4); kl.castShadow = true; scene.add(kl);
  var fl = new THREE.DirectionalLight(0xc8d0e0, 0.4);
  fl.position.set(-3, 2, -2); scene.add(fl);
  var rl = new THREE.DirectionalLight(0xe8ecf2, 0.5);
  rl.position.set(0, 3, -4); scene.add(rl);

  var mannequin = new THREE.Group();
  mannequin.position.y = -0.15;
  scene.add(mannequin);

  // Set up Draco decoder for compressed GLB
  var dracoLoader = new THREE.DRACOLoader();
  dracoLoader.setDecoderPath('https://www.gstatic.com/draco/versioned/decoders/1.5.6/');
  dracoLoader.setDecoderConfig({ type: 'js' });

  // Load GLB using fetch + parse for reliability
  fetch('mannequin.glb')
    .then(function(r) {
      if (!r.ok) throw new Error('HTTP ' + r.status);
      return r.arrayBuffer();
    })
    .then(function(buf) {
      var loader = new THREE.GLTFLoader();
      loader.setDRACOLoader(dracoLoader);
      loader.parse(buf, '', function(gltf) {
        var model = gltf.scene;
        var box = new THREE.Box3().setFromObject(model);
        var size = box.getSize(new THREE.Vector3());
        var scale = 2.0 / size.y;
        model.scale.setScalar(scale);
        box.setFromObject(model);
        var center = box.getCenter(new THREE.Vector3());
        model.position.x = -center.x;
        model.position.z = -center.z;
        model.position.y = -box.min.y - 0.85;

        var greyMat = new THREE.MeshStandardMaterial({ color: 0xc8ccd4, roughness: 0.55, metalness: 0.05 });
        model.traverse(function(child) {
          if (child.isMesh) { child.material = greyMat; child.castShadow = true; child.receiveShadow = true; }
        });
        mannequin.add(model);
      }, function(e) {
        var d = document.createElement('div');
        d.style.cssText = 'position:fixed;top:10px;left:10px;background:orange;color:white;padding:10px;z-index:999;font-size:14px;max-width:90%';
        d.textContent = 'Parse Error: ' + (e.message || JSON.stringify(e));
        document.body.appendChild(d);
      });
    })
    .catch(function(e) {
      var d = document.createElement('div');
      d.style.cssText = 'position:fixed;top:10px;left:10px;background:red;color:white;padding:10px;z-index:999;font-size:14px;max-width:90%';
      d.textContent = 'Fetch Error: ' + e.message;
      document.body.appendChild(d);
    });

  // Measurement visuals
  function dRing(radius, y, color) {
    var pts = [];
    for (var i = 0; i <= 128; i++) { var a = (i / 128) * Math.PI * 2; pts.push(new THREE.Vector3(Math.cos(a) * radius, y, Math.sin(a) * radius)); }
    var g = new THREE.BufferGeometry().setFromPoints(pts);
    var m = new THREE.LineDashedMaterial({ color: color || 0x3a3a5c, transparent: true, opacity: 0.3, dashSize: 0.03, gapSize: 0.02 });
    var l = new THREE.Line(g, m); l.computeLineDistances(); return l;
  }
  mannequin.add(dRing(0.24, 0.78, 0x2a2a4a));
  mannequin.add(dRing(0.18, 0.4, 0x2a2a4a));

  var armPts = [new THREE.Vector3(0.3, 0.85, 0), new THREE.Vector3(0.355, 0.02, 0)];
  var armGeo = new THREE.BufferGeometry().setFromPoints(armPts);
  var armMat2 = new THREE.LineDashedMaterial({ color: 0x2a2a4a, transparent: true, opacity: 0.3, dashSize: 0.03, gapSize: 0.02 });
  var armLine = new THREE.Line(armGeo, armMat2); armLine.computeLineDistances(); mannequin.add(armLine);

  var tMat = new THREE.MeshBasicMaterial({ color: 0x2a2a4a, transparent: true, opacity: 0.5 });
  [[0.3, 0.85], [0.355, 0.02]].forEach(function(p) {
    var t = new THREE.Mesh(new THREE.SphereGeometry(0.008, 8, 8), tMat); t.position.set(p[0], p[1], 0); mannequin.add(t);
  });

  var floorGeo = new THREE.CircleGeometry(0.8, 32);
  var floorMat = new THREE.MeshBasicMaterial({ color: 0xc0c4cc, transparent: true, opacity: 0.15 });
  var floorMesh = new THREE.Mesh(floorGeo, floorMat); floorMesh.rotation.x = -Math.PI / 2; floorMesh.position.y = -0.88; mannequin.add(floorMesh);

  var anchors = { arm: new THREE.Vector3(0.42, 0.45, 0), chest: new THREE.Vector3(-0.32, 0.78, 0), waist: new THREE.Vector3(-0.26, 0.4, 0) };

  var isDragging = false, prevX = 0, rotVel = 0, targetRot = 0, curRot = 0;
  container.addEventListener('pointerdown', function(e) { isDragging = true; prevX = e.clientX; rotVel = 0; });
  container.addEventListener('pointermove', function(e) { if (!isDragging) return; var d = e.clientX - prevX; rotVel = d * 0.008; targetRot += rotVel; prevX = e.clientX; });
  container.addEventListener('pointerup', function() { isDragging = false; });
  container.addEventListener('pointerleave', function() { isDragging = false; });
  container.addEventListener('touchstart', function(e) { isDragging = true; prevX = e.touches[0].clientX; rotVel = 0; }, { passive: true });
  container.addEventListener('touchmove', function(e) { if (!isDragging) return; var d = e.touches[0].clientX - prevX; rotVel = d * 0.008; targetRot += rotVel; prevX = e.touches[0].clientX; }, { passive: true });
  container.addEventListener('touchend', function() { isDragging = false; });

  function toScreen(p) { var v = p.clone(); v.project(camera); return { x: (v.x * 0.5 + 0.5) * container.clientWidth, y: (-v.y * 0.5 + 0.5) * container.clientHeight }; }

  var labelArm = document.getElementById('label-arm');
  var labelChest = document.getElementById('label-chest');
  var labelWaist = document.getElementById('label-waist');

  function updateLabels() {
    mannequin.updateMatrixWorld();
    var a = {};
    Object.keys(anchors).forEach(function(k) { a[k] = anchors[k].clone().applyMatrix4(mannequin.matrixWorld); });
    var sa = toScreen(a.arm), sc = toScreen(a.chest), sw = toScreen(a.waist);
    labelArm.style.left = (sa.x - 10) + 'px'; labelArm.style.top = (sa.y - 15) + 'px';
    labelChest.style.left = (sc.x - 60) + 'px'; labelChest.style.top = (sc.y - 15) + 'px';
    labelWaist.style.left = (sw.x - 55) + 'px'; labelWaist.style.top = (sw.y - 15) + 'px';
    var forward = new THREE.Vector3(0, 0, 1).applyQuaternion(mannequin.quaternion);
    var rightDir = new THREE.Vector3(1, 0, 0).applyQuaternion(mannequin.quaternion);
    var leftDir = new THREE.Vector3(-1, 0, 0).applyQuaternion(mannequin.quaternion);
    var camDir = new THREE.Vector3(0, 0, 1);
    labelArm.style.opacity = Math.pow(Math.max(0, -rightDir.dot(camDir)), 0.6) * 0.95;
    var frontVis = Math.max(0, forward.dot(camDir));
    var sideVis = Math.abs(leftDir.dot(camDir));
    var bodyVis = Math.max(frontVis, sideVis * 0.6);
    labelChest.style.opacity = Math.pow(bodyVis, 0.8) * 0.9;
    labelWaist.style.opacity = Math.pow(bodyVis, 0.8) * 0.9;
  }

  function animate() {
    requestAnimationFrame(animate);
    if (!isDragging) { targetRot += 0.003; rotVel *= 0.95; targetRot += rotVel; }
    curRot += (targetRot - curRot) * 0.08;
    mannequin.rotation.y = curRot;
    mannequin.position.y = -0.15 + Math.sin(Date.now() * 0.001) * 0.003;
    updateLabels();
    renderer.render(scene, camera);
  }
  animate();

  window.addEventListener('resize', function() {
    camera.aspect = container.clientWidth / container.clientHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(container.clientWidth, container.clientHeight);
  });
})();
</script>
</body>
</html>
